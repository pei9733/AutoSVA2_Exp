// This property file was autogenerated by AutoSVA on 2024-09-25
// to check the behavior of the original RTL module, whose interface is described below: 
module fifo2_prop
#(
		parameter ASSERT_INPUTS = 0,
		parameter INFLIGHT_IDX = 2, // Log2 of the number of slots
		parameter SIZE = 4 // Width of the data slot
)
(		// Clock + Reset
		input  wire                          clk,
		input  wire                          rst_n,
		
		input  wire                          in_val,
		input  wire                          in_rdy, //output
		input  wire [SIZE-1:0]               in_data,
		
		input  wire                          out_val, //output
		input  wire                          out_rdy,
		input  wire [SIZE-1:0]               out_data //output
	);

//==============================================================================
// Local Parameters
//==============================================================================

genvar j;
default clocking cb @(posedge clk);
endclocking
default disable iff (!rst_n);

// Re-defined wires 
wire [INFLIGHT_IDX-1:0] in_transid;
wire [INFLIGHT_IDX-1:0] out_transid;

// Symbolics and Handshake signals
wire in_hsk = in_val && in_rdy;
wire out_hsk = out_val && out_rdy;
wire [INFLIGHT_IDX-1:0] symb_in_transid;
am__symb_in_transid_stable: assume property($stable(symb_in_transid));

//==============================================================================
// Modeling
//==============================================================================

// Modeling incoming request for fifo
if (ASSERT_INPUTS) begin
	as__fifo_fairness: assert property (out_val |-> s_eventually(out_rdy));
end else begin
	am__fifo_fairness: assume property (out_val |-> s_eventually(out_rdy));
end

// Generate sampling signals and model
reg [3:0] fifo_transid_sampled;
wire fifo_transid_set = in_hsk && in_transid == symb_in_transid;
wire fifo_transid_response = out_hsk && out_transid == symb_in_transid;

always_ff @(posedge clk) begin
	if(!rst_n) begin
		fifo_transid_sampled <= '0;
	end else if (fifo_transid_set || fifo_transid_response ) begin
		fifo_transid_sampled <= fifo_transid_sampled + fifo_transid_set - fifo_transid_response;
	end
end
co__fifo_transid_sampled: cover property (|fifo_transid_sampled);
if (ASSERT_INPUTS) begin
	as__fifo_transid_sample_no_overflow: assert property (fifo_transid_sampled != '1 || !fifo_transid_set);
end else begin
	am__fifo_transid_sample_no_overflow: assume property (fifo_transid_sampled != '1 || !fifo_transid_set);
end


// Assert that if valid eventually ready or dropped valid
as__fifo_transid_hsk_or_drop: assert property (in_val |-> s_eventually(!in_val || in_rdy));
// Assert that every request has a response and that every reponse has a request
as__fifo_transid_eventual_response: assert property (|fifo_transid_sampled |-> s_eventually(out_val && (out_transid == symb_in_transid) ));
as__fifo_transid_was_a_request: assert property (fifo_transid_response |-> fifo_transid_set || fifo_transid_sampled);


// Modeling data integrity for fifo_transid
reg [SIZE-1:0] fifo_transid_data_model;
always_ff @(posedge clk) begin
	if(!rst_n) begin
		fifo_transid_data_model <= '0;
	end else if (fifo_transid_set) begin
		fifo_transid_data_model <= in_data;
	end
end

as__fifo_transid_data_unique: assert property (|fifo_transid_sampled |-> !fifo_transid_set);
as__fifo_transid_data_integrity: assert property (|fifo_transid_sampled && fifo_transid_response |-> (out_data == fifo_transid_data_model));

assign in_transid = fifo2.wr_ptr_reg;
assign out_transid = fifo2.rd_ptr_reg;

//====DESIGNER-ADDED-SVA====//

// *** GPT4-GENERATED SVA BATCH *** //
// Property file

// Assertion to check correct functionality of write pointer register
// If data is valid and ready for input, in the next cycle the write pointer register should be incremented by 1
asgpt__wr_ptr_update: assert property (
    @(posedge clk) (fifo2.in_val && fifo2.in_rdy) |=> $past(fifo2.wr_ptr_reg) + 1'b1 == fifo2.wr_ptr_reg
);

// Assertion to check correct functionality of read pointer register
// If data is valid and ready for output, in the next cycle the read pointer register should be incremented by 1
asgpt__rd_ptr_update: assert property (
    @(posedge clk) (fifo2.out_val && fifo2.out_rdy) |=> $past(fifo2.rd_ptr_reg) + 1'b1 == fifo2.rd_ptr_reg
);

// Assertion to check correct functionality of input ready signal
// If fifo2 is not full, in_rdy should be high
asgpt__in_rdy: assert property (
    @(posedge clk) (!fifo2.full_reg) |-> fifo2.in_rdy
);

// Assertion to check correct functionality of output valid signal
// If fifo2 is not empty, out_val should be high
asgpt__out_val: assert property (
    @(posedge clk) (!fifo2.empty_reg) |-> fifo2.out_val
);

// Assertion to check correct functionality of fifo2 when data is written
// If data is valid and ready for input, in the next cycle the data should be stored in fifo2 at the location pointed by the write pointer
asgpt__write_fifo: assert property (
    @(posedge clk) (fifo2.in_val && fifo2.in_rdy) |=> $past(fifo2.in_data) == fifo2.fifo_storage_reg[$past(fifo2.wr_ptr_reg)]
);

// Assertion to check correct functionality of fifo2 when data is read
// If data is valid and ready for output, the data read should be the one stored in fifo2 at the location pointed by the read pointer
asgpt__read_fifo: assert property (
    @(posedge clk) (fifo2.out_val && fifo2.out_rdy) |-> fifo2.out_data == fifo2.fifo_storage_reg[fifo2.rd_ptr_reg]
);

// Assertion to check correct functionality of full register
// If write pointer is about to overlap read pointer, fifo2 should be marked as full
asgpt__full_reg: assert property (
    @(posedge clk) (fifo2.in_val && fifo2.in_rdy && fifo2.next_wr_ptr[fifo2.INFLIGHT_IDX-1:0] == fifo2.rd_ptr_reg) |=> fifo2.full_reg
);

// Assertion to check correct functionality of empty register
// If read pointer is about to overlap write pointer, fifo2 should be marked as empty
asgpt__empty_reg: assert property (
    @(posedge clk) (fifo2.out_val && fifo2.out_rdy && fifo2.wr_ptr_reg == fifo2.next_rd_ptr[fifo2.INFLIGHT_IDX-1:0]) |=> fifo2.empty_reg
);
// *** END OF GPT4-GENERATED SVA BATCH ***//
endmodule